# HydroFarm Developer Contract

## 1️⃣ Структура проекта на GitHub

Проект на GitHub: `hydrofarm-system`

# HydroFarm Developer Contract

## 1️⃣ Структура проекта на GitHub

Проект на GitHub: `hydrofarm-system`

```
hydrofarm-system/
├── backend/ # Python код для работы с Raspberry Pi и ESP32
├── docker/ # Docker-файлы и контейнеры (MQTT, PostgreSQL)
├── docs/
│ ├── schematics/ # Visio и PDF схемы подключения
│ ├── manuals/ # Руководства пользователя
│ └── contracts/ # Контракты и инструкции для разработчиков
├── esp32/ # Код и конфигурации для ESP32
├── web/ # Веб-интерфейс (HTML, CSS, JS)
├── .gitignore
├── LICENSE
└── README.md
```

**Примечания:**

- Все изменения в проекте должны фиксироваться через GitHub.
- Каждый новый модуль (ESP32, датчик, насос) добавляется в соответствующую папку и сопровождается документацией в `docs/`.

---

## 2️⃣ Общие правила для разработчиков

1. Все изменения **вносятся через GitHub** с коммитами и описанием.
2. Для крупных изменений используем **ветки (branches)** и pull requests.
3. Каждый разработчик должен согласовывать новые сенсоры и модули в контракте.
4. Все датчики и устройства должны быть описаны в таблице, как в нашем примере для Raspberry Pi и ESP32.

---

## 3️⃣ Подключения и устройства

### Raspberry Pi 5 (основной сервер)

- Отвечает за питание и управление насосами, клапанами, светом и вентиляторами.
- Подключается к ESP32 через Wi-Fi / Ethernet.

#### Таблица для программиста

| №  | GPIO        | Название       | Тип          | Описание                                | Дополнительная инф.                   | I²C Address |
|----|------------|----------------|-------------|----------------------------------------|--------------------------------------|-------------|
| 1  | 21         | FLOW_SENSOR_1  | INPUT       | Импульсы расхода воды                  | ACTIVE LOW                            | -           |
| 2  | 26         | INLET_VALVE_1  | OUTPUT      | Клапан подачи воды 12V                 | ACTIVE LOW                            | -           |
| 3  | 17         | PUMP_1         | OUTPUT      | Насос 1 (основной)                     | ACTIVE LOW                            | -           |
| 4  | 27         | PUMP_2         | OUTPUT      | Насос 2 (резервный)                    | ACTIVE LOW                            | -           |
| 5  | 5          | PUMP_3         | OUTPUT      | Насос 3 (дозирующий)                   | ACTIVE LOW                            | -           |
| 6  | 6          | PUMP_4         | OUTPUT      | Насос 4 (дозирующий)                   | ACTIVE LOW                            | -           |
| 7  | 13         | PUMP_5         | OUTPUT      | Насос 5 (дозирующий)                   | ACTIVE LOW                            | -           |
| 8  | 19         | PUMP_6         | OUTPUT      | Насос 6 (дозирующий)                   | ACTIVE LOW                            | -           |
| 9  | 22         | LIGHT_1        | OUTPUT      | Свет                                   | RELAY, 5V, ACTIVE LOW                 | -           |
| 10 | 23         | FAN_1          | OUTPUT      | Вентиляторы                             | RELAY, 5V, ACTIVE LOW                 | -           |
| 11 | 24         | FILL_VALVE_2   | OUTPUT      | Клапан долива                           | RELAY, 5V, ACTIVE LOW                 | -           |
| 12 | A0 (ADS1115)| PH_SENSOR      | ANALOG_INPUT| pH-датчик через делитель 10k/10k       | ADC ×2 для реального значения         | 0x48        |
| 13 | A1 (ADS1115)| TDS_SENSOR     | ANALOG_INPUT| TDS-датчик через делитель 10k/10k      | ADC ×2 для реального значения         | 0x49        |
| 14 | 4          | WATER_TEMP_1   | INPUT       | Температура воды (DS18B20, 1-Wire)    | Подтяжка 4.7kΩ, питание 3.3V AMS1117 | -           |
| 15 | 18         | ULTRASONIC_TRIG_1 | OUTPUT   | УЗ датчик уровня (Trig)                | 3.3V                                   | -           |
| 16 | 25         | ULTRASONIC_ECHO_1 | INPUT    | УЗ датчик уровня (Echo)                | 5V → 3.3V делитель                     | -           |

---

### ESP32 (модули для масштабирования)

- Отвечает за удалённые датчики (I²C, аналоговые, цифровые).

#### Таблица для программиста ESP32

| №  | GPIO | Название     | Тип           | Описание                       | Дополнительная инф.         | I²C Address |
|----|------|-------------|---------------|--------------------------------|-----------------------------|-------------|
| 1  | 21   | CJMCU-811   | I2C           | CO2 / VOC датчик               | 3.3V, GND, SDA/SCL         | 0x5A        |
| 2  | 22   | GY-30       | I2C           | Световой датчик BH1750         | 3.3V, GND, SDA/SCL         | 0x23        |
| 3  | 34   | HW-103 / HW-028 | ANALOG_INPUT| Влажность почвы               | 3.3V, GND                  | -           |
| 4  | 4    | DHT22       | DIGITAL       | Температура и влажность воздуха | 3.3V, GND, DATA           | -           |

---

## 4️⃣ Масштабируемость и новые устройства

- Любой новый датчик / ESP32 модуль:
  1. Создаётся папка в `esp32/` или `backend/`.
  2. Добавляется запись в таблицу подключений.
  3. Все I²C устройства должны иметь уникальный адрес.
- Пользователь должен иметь возможность через веб-интерфейс добавлять новые устройства **без изменения кода вручную**.

---

## 5️⃣ Docker и Backend

- **Docker**:
  - Mosquitto → брокер MQTT для передачи данных от ESP32.
  - PostgreSQL → основная база данных.
- **Backend (Python)**:
  - Считывает данные с Raspberry Pi и ESP32.
  - Обрабатывает сигналы и пишет в БД.
  - Предоставляет API для веб-интерфейса.
- **Web / API (HTML + CSS + JS)**:
  - Отображение данных пользователю.
  - Добавление новых датчиков и устройств.
  - Взаимодействие с Backend через REST или WebSocket.

---

## 6️⃣ Контракт для разработчиков

1. Все файлы должны сохраняться в **соответствующих папках**.
2. Любой новый функционал согласуется с командой.
3. Ветки и Pull Requests используются для согласования изменений.
4. Таблицы подключения датчиков должны быть всегда актуальны.
5. Любой новый модуль I²C или аналоговый датчик:
   - Проверяется на уникальный адрес.
   - Подключение документируется в `docs/schematics/` и в `developer_contract.md`.
6. История изменений хранится через GitHub → каждый разработчик всегда видит, кто и что изменял.

---

## 7️⃣ Пример JSON-конфигурации для нового датчика ESP32

```json
{
  "device_id": "esp32_module_01",
  "sensors": [
    {
      "type": "CJMCU-811",
      "pin": "I2C",
      "i2c_address": "0x5A"
    },
    {
      "type": "GY-30",
      "pin": "I2C",
      "i2c_address": "0x23"
    }
  ]
}


**Примечания:**

- Все изменения в проекте должны фиксироваться через GitHub.
- Каждый новый модуль (ESP32, датчик, насос) добавляется в соответствующую папку и сопровождается документацией в `docs/`.

---

## 2️⃣ Общие правила для разработчиков

1. Все изменения **вносятся через GitHub** с коммитами и описанием.
2. Для крупных изменений используем **ветки (branches)** и pull requests.
3. Каждый разработчик должен согласовывать новые сенсоры и модули в контракте.
4. Все датчики и устройства должны быть описаны в таблице, как в нашем примере для Raspberry Pi и ESP32.

---

## 3️⃣ Подключения и устройства

### Raspberry Pi 5 (основной сервер)

- Отвечает за питание и управление насосами, клапанами, светом и вентиляторами.
- Подключается к ESP32 через Wi-Fi / Ethernet.

#### Таблица для программиста

| №  | GPIO        | Название       | Тип          | Описание                                | Дополнительная инф.                   | I²C Address |
|----|------------|----------------|-------------|----------------------------------------|--------------------------------------|-------------|
| 1  | 21         | FLOW_SENSOR_1  | INPUT       | Импульсы расхода воды                  | ACTIVE LOW                            | -           |
| 2  | 26         | INLET_VALVE_1  | OUTPUT      | Клапан подачи воды 12V                 | ACTIVE LOW                            | -           |
| 3  | 17         | PUMP_1         | OUTPUT      | Насос 1 (основной)                     | ACTIVE LOW                            | -           |
| 4  | 27         | PUMP_2         | OUTPUT      | Насос 2 (резервный)                    | ACTIVE LOW                            | -           |
| 5  | 5          | PUMP_3         | OUTPUT      | Насос 3 (дозирующий)                   | ACTIVE LOW                            | -           |
| 6  | 6          | PUMP_4         | OUTPUT      | Насос 4 (дозирующий)                   | ACTIVE LOW                            | -           |
| 7  | 13         | PUMP_5         | OUTPUT      | Насос 5 (дозирующий)                   | ACTIVE LOW                            | -           |
| 8  | 19         | PUMP_6         | OUTPUT      | Насос 6 (дозирующий)                   | ACTIVE LOW                            | -           |
| 9  | 22         | LIGHT_1        | OUTPUT      | Свет                                   | RELAY, 5V, ACTIVE LOW                 | -           |
| 10 | 23         | FAN_1          | OUTPUT      | Вентиляторы                             | RELAY, 5V, ACTIVE LOW                 | -           |
| 11 | 24         | FILL_VALVE_2   | OUTPUT      | Клапан долива                           | RELAY, 5V, ACTIVE LOW                 | -           |
| 12 | A0 (ADS1115)| PH_SENSOR      | ANALOG_INPUT| pH-датчик через делитель 10k/10k       | ADC ×2 для реального значения         | 0x48        |
| 13 | A1 (ADS1115)| TDS_SENSOR     | ANALOG_INPUT| TDS-датчик через делитель 10k/10k      | ADC ×2 для реального значения         | 0x49        |
| 14 | 4          | WATER_TEMP_1   | INPUT       | Температура воды (DS18B20, 1-Wire)    | Подтяжка 4.7kΩ, питание 3.3V AMS1117 | -           |
| 15 | 18         | ULTRASONIC_TRIG_1 | OUTPUT   | УЗ датчик уровня (Trig)                | 3.3V                                   | -           |
| 16 | 25         | ULTRASONIC_ECHO_1 | INPUT    | УЗ датчик уровня (Echo)                | 5V → 3.3V делитель                     | -           |

---

### ESP32 (модули для масштабирования)

- Отвечает за удалённые датчики (I²C, аналоговые, цифровые).

#### Таблица для программиста ESP32

| №  | GPIO | Название     | Тип           | Описание                       | Дополнительная инф.         | I²C Address |
|----|------|-------------|---------------|--------------------------------|-----------------------------|-------------|
| 1  | 21   | CJMCU-811   | I2C           | CO2 / VOC датчик               | 3.3V, GND, SDA/SCL         | 0x5A        |
| 2  | 22   | GY-30       | I2C           | Световой датчик BH1750         | 3.3V, GND, SDA/SCL         | 0x23        |
| 3  | 34   | HW-103 / HW-028 | ANALOG_INPUT| Влажность почвы               | 3.3V, GND                  | -           |
| 4  | 4    | DHT22       | DIGITAL       | Температура и влажность воздуха | 3.3V, GND, DATA           | -           |

---

## 4️⃣ Масштабируемость и новые устройства

- Любой новый датчик / ESP32 модуль:
  1. Создаётся папка в `esp32/` или `backend/`.
  2. Добавляется запись в таблицу подключений.
  3. Все I²C устройства должны иметь уникальный адрес.
- Пользователь должен иметь возможность через веб-интерфейс добавлять новые устройства **без изменения кода вручную**.

---

## 5️⃣ Docker и Backend

- **Docker**:
  - Mosquitto → брокер MQTT для передачи данных от ESP32.
  - PostgreSQL → основная база данных.
- **Backend (Python)**:
  - Считывает данные с Raspberry Pi и ESP32.
  - Обрабатывает сигналы и пишет в БД.
  - Предоставляет API для веб-интерфейса.
- **Web / API (HTML + CSS + JS)**:
  - Отображение данных пользователю.
  - Добавление новых датчиков и устройств.
  - Взаимодействие с Backend через REST или WebSocket.

---

## 6️⃣ Контракт для разработчиков

1. Все файлы должны сохраняться в **соответствующих папках**.
2. Любой новый функционал согласуется с командой.
3. Ветки и Pull Requests используются для согласования изменений.
4. Таблицы подключения датчиков должны быть всегда актуальны.
5. Любой новый модуль I²C или аналоговый датчик:
   - Проверяется на уникальный адрес.
   - Подключение документируется в `docs/schematics/` и в `developer_contract.md`.
6. История изменений хранится через GitHub → каждый разработчик всегда видит, кто и что изменял.

---

## 7️⃣ Пример JSON-конфигурации для нового датчика ESP32

```json
{
  "device_id": "esp32_module_01",
  "sensors": [
    {
      "type": "CJMCU-811",
      "pin": "I2C",
      "i2c_address": "0x5A"
    },
    {
      "type": "GY-30",
      "pin": "I2C",
      "i2c_address": "0x23"
    }
  ]
}

8️⃣ Добавление новых устройств через веб-интерфейс

Цель: пользователь или администратор может добавлять новые ESP32-модули и датчики без редактирования исходного кода напрямую.

8.1 Процесс добавления нового устройства

В веб-интерфейсе есть форма “Добавить устройство”.

Пользователь выбирает тип устройства:

ESP32-модуль

Датчик (I²C, аналоговый, цифровой)

Вводятся параметры:

device_id — уникальный идентификатор устройства

sensors — список датчиков с типом, пином и I²C адресом (если есть)

Нажимает “Сохранить”, данные отправляются на Backend (Python) через REST API или WebSocket.

Backend проверяет:

уникальность device_id

уникальность I²C адресов для всех I²C устройств

корректность подключений

Backend добавляет новую запись в базу данных PostgreSQL.

Backend уведомляет MQTT-брокер (Mosquitto), чтобы ESP32 и Raspberry Pi синхронизировали данные.

8.2 Пример JSON для нового устройства
{
  "device_id": "esp32_module_02",
  "location": "Greenhouse 1",
  "sensors": [
    {
      "type": "DHT22",
      "pin": "GPIO4",
      "i2c_address": null
    },
    {
      "type": "HW-103",
      "pin": "A0",
      "i2c_address": null
    },
    {
      "type": "CJMCU-811",
      "pin": "I2C",
      "i2c_address": "0x5A"
    }
  ]
}

8.3 Backend обработка

Backend (Python) получает JSON и:

Проверяет корректность структуры.

Проверяет уникальность device_id.

Проверяет I²C адреса на уникальность.

Вносит данные в базу PostgreSQL.

Отправляет событие через MQTT Mosquitto для синхронизации ESP32.

8.4 Масштабируемость

Система автоматически поддерживает добавление любого количества новых ESP32 и датчиков.

Не нужно менять исходный код проекта, только через веб-интерфейс и базу данных.

История всех подключений сохраняется в БД и через GitHub в документации (docs/schematics/ и developer_contract.md).
8.3 Backend обработка

Backend (Python) получает JSON и:

Проверяет корректность структуры.

Проверяет уникальность device_id.

Проверяет I²C адреса на уникальность.

Вносит данные в базу PostgreSQL.

Отправляет событие через MQTT Mosquitto для синхронизации ESP32.

8.4 Масштабируемость

Система автоматически поддерживает добавление любого количества новых ESP32 и датчиков.

Не нужно менять исходный код проекта, только через веб-интерфейс и базу данных.

История всех подключений сохраняется в БД и через GitHub в документации (docs/schematics/ и developer_contract.md).
